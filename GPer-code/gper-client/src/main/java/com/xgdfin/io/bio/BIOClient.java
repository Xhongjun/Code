package com.xgdfin.io.bio;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/* * Copyright (C) 2017  ShenZhen xinLianZhengXin Co.,Ltd All Rights Reserved. * 未经本公司正式书面同意，其他任何个人、团体不得使用、复制、修改或发布本软件. * 版权所有深圳市信联征信有限公司 http://www.credlink.com/ */public class BIOClient {    static ExecutorService cachedThreadPool = Executors.newCachedThreadPool();    public static void main(String[] args) {        connectMulti(4);    }    // 创建多个线程发送请求，模拟多个客户端;    public static void connectMulti(int clientNum) {        for (int i = 0; i < clientNum; i++) {            int cnt = i;            cachedThreadPool.execute(new Runnable() {                @Override                public void run() {                    InputStream inputStream = null;                    OutputStream outputStream = null;                    byte[] returnBuffer = new byte[512];                    try {                        // 客户端建立连接                        Socket clientSocket = new Socket("127.0.0.1", 8081);                        // 向服务端发送数据                        outputStream = clientSocket.getOutputStream();                        String msg = String.valueOf(new Random().nextInt(100));                        outputStream.write(msg.getBytes());                        System.out.println("客户端【" + cnt + "】发送数据：" + msg);                        System.out.println("客户端【" + cnt + "】等待服务端返回数据...");                        //阻塞中，等待服务端的依此返回                        // 获得客户端返回数据                        inputStream = clientSocket.getInputStream();                        inputStream.read(returnBuffer);                        System.out.println("服务端返回数据给客户端【" + cnt + "】：" + new String(returnBuffer));                        System.out.println("给客户端【" + cnt + "】接着做业务");                    } catch (IOException e) {                        e.printStackTrace();                    } finally {                        try {                            if (inputStream != null) {                                inputStream.close();                            }                        } catch (IOException e) {                            e.printStackTrace();                        }                        try {                            if (outputStream != null) {                                outputStream.close();                            }                        } catch (IOException e) {                            e.printStackTrace();                        }                    }                }            });        }    }}