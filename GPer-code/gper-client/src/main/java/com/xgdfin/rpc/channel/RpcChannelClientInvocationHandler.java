package com.xgdfin.rpc.channel;import com.xgdfin.rpc.RpcRequest;import io.netty.bootstrap.Bootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LengthFieldBasedFrameDecoder;import io.netty.handler.codec.LengthFieldPrepender;import io.netty.handler.codec.serialization.ClassResolvers;import io.netty.handler.codec.serialization.ObjectDecoder;import io.netty.handler.codec.serialization.ObjectEncoder;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** Copyright (C) 2017  ShenZhen xinLianZhengXin Co.,Ltd All Rights Reserved.* 未经本公司正式书面同意，其他任何个人、团体不得使用、复制、修改或发布本软件.* 版权所有深圳市信联征信有限公司 http://www.credlink.com/*/public class RpcChannelClientInvocationHandler implements InvocationHandler {    private Class<?> clazz;    private String host;    private int port;    public RpcChannelClientInvocationHandler(Class<?> clazz, String host, int port) {        this.clazz = clazz;        this.host = host;        this.port = port;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        Object response = null;        // 传进来的是一个已实现的具体类        if (Object.class.equals(clazz.getDeclaringClass())) {            return method.invoke(clazz, args);        } else {            response = rpcInvoke(method, args);        }        return response;    }    // 发送服务请求    private Object rpcInvoke(Method method, Object[] args) {        // 请求参数组装        RpcRequest request = new RpcRequest();        request.setClassName(clazz.getCanonicalName());        request.setMethodName(method.getName());        request.setVersion("v2.0");        request.setParamesType(args);        RpcChannelClientProxyHandle clientProxyHandle = new RpcChannelClientProxyHandle();        EventLoopGroup workerGroup = new NioEventLoopGroup();        try {            Bootstrap bootstrap = new Bootstrap();            bootstrap.group(workerGroup)                    .channel(NioSocketChannel.class)                    .option(ChannelOption.TCP_NODELAY, true)                    .handler(new ChannelInitializer<SocketChannel>() {                        // 初始化通道                        @Override                        protected void initChannel(SocketChannel ch) throws Exception {                            //自定义协议解码器                            /**                             * 入参有5个，分别解释如下                             * maxFrameLength：框架的最大长度。如果帧的长度大于此值，则将抛出TooLongFrameException。                             * lengthFieldOffset：长度字段的偏移量：即对应的长度字段在整个消息数据中得位置                             * lengthFieldLength：长度字段的长度。如：长度字段是int型表示，那么这个值就是4（long型就是8）                             * lengthAdjustment：要添加到长度字段值的补偿值                             * initialBytesToStrip：从解码帧中去除的第一个字节数                             */                            ChannelPipeline pipeline = ch.pipeline();                            pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));                            // 自定义协议编码器                            pipeline.addLast(new LengthFieldPrepender(4));                            // 对象参数类型编码器                            pipeline.addLast("encoder", new ObjectEncoder());                            // 对象参数类型解码器                            pipeline.addLast("decoder", new ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(null)));                            // 自定义注册处理器                            pipeline.addLast("handler", clientProxyHandle);                        }                    });            ChannelFuture future = bootstrap.connect(host, port).sync();            future.channel().writeAndFlush(request).sync();            future.channel().closeFuture().sync();        } catch (Exception e) {            e.printStackTrace();        } finally {            workerGroup.shutdownGracefully();        }        return clientProxyHandle.getResponse();    }}