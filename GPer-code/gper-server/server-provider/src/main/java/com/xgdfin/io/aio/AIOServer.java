package com.xgdfin.io.aio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousChannelGroup;import java.nio.channels.AsynchronousServerSocketChannel;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** Copyright (C) 2017  ShenZhen xinLianZhengXin Co.,Ltd All Rights Reserved.* 未经本公司正式书面同意，其他任何个人、团体不得使用、复制、修改或发布本软件.* 版权所有深圳市信联征信有限公司 http://www.credlink.com/*/public class AIOServer {    private int port;    public AIOServer(int port) {        this.port = port;    }    public void listen() {       try {           ExecutorService cachedThreadPool = Executors.newCachedThreadPool();           AsynchronousChannelGroup channelGroup = AsynchronousChannelGroup.withCachedThreadPool(cachedThreadPool, 1);           // 工作线程，用于监听回调，事件响应的时候需要回调           AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open(channelGroup);           serverSocketChannel.bind(new InetSocketAddress(port));           System.out.println("服务已启动，监听端口："+port);           // 准备接收请求           serverSocketChannel.accept(null, new CompletionHandler<AsynchronousSocketChannel, Object>() {               final ByteBuffer buffer = ByteBuffer.allocate(1024);               // 由操作系统来触发回调               @Override               public void completed(AsynchronousSocketChannel result, Object attachment) {                   System.out.println("I/O 操作成功，开始获取数据");                   try {                       buffer.clear();                       result.read(buffer).get();                       System.out.println("aio 服务端获取到数据：" + new String(buffer.array()));                       buffer.flip();                       result.write(ByteBuffer.wrap("服务端返回一条测试数据".getBytes()));                       buffer.flip();                   } catch (Exception e) {                       e.printStackTrace();                   } finally {                       try {                           result.close();                       } catch (IOException e) {                           e.printStackTrace();                       }                       System.out.println("操作完成");                   }               }               @Override               public void failed(Throwable exc, Object attachment) {                   System.out.println("I/O 操作异常");                   exc.printStackTrace();               }           });            Thread.sleep(10000);       } catch (Exception e) {           e.printStackTrace();       }    }    public static void main(String[] args) {        new AIOServer(8089).listen();    }}