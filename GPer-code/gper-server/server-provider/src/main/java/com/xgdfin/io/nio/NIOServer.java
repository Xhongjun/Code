package com.xgdfin.io.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Set;/** Copyright (C) 2017  ShenZhen xinLianZhengXin Co.,Ltd All Rights Reserved.* 未经本公司正式书面同意，其他任何个人、团体不得使用、复制、修改或发布本软件.* 版权所有深圳市信联征信有限公司 http://www.credlink.com/*/public class NIOServer {    private int port;    // 选择器（叫号器）    private Selector selector;    // 数据缓冲区    private ByteBuffer buffer = ByteBuffer.allocate(1024);    public NIOServer(int port) {        this.port = port;        try {            // 创建一个 socket 通道            ServerSocketChannel serverSocket = ServerSocketChannel.open();            serverSocket.bind(new InetSocketAddress("127.0.0.1", port));            // NIO 为 BIO 的升级版本，为了兼容 BIO，            // NIO 模型默认时采用阻塞式            serverSocket.configureBlocking(false);            // 初始化选择器            selector = Selector.open();            // 将选择器注册到用到上，并表明可以接受新的请求            serverSocket.register(selector, SelectionKey.OP_ACCEPT);        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        new NIOServer(8081).listen();    }    // 服务监听    public void listen() {        System.out.println("nio 服务启动，开始监听端口：" + port);        try {            while (true) {                // 叫号                selector.select();                // selector 中为多个客户端的 I/O 请求信息（及多个 channel）                // 每个 key 对应一个客户端的请求                Set<SelectionKey> keys = selector.selectedKeys();                Iterator<SelectionKey> iterator = keys.iterator();                // 不断轮询注册在 select 中的 I/O                while (iterator.hasNext()) {                    // 依此轮询每个 I/O                    SelectionKey key = iterator.next();                    iterator.remove(); // 为什么要移除这个 key ？                    // 处理业务                    process(key);                }            }        } catch (Exception e) {            e.printStackTrace();        }    }    // 服务处理    public void process(SelectionKey key) throws IOException {        // 连接就绪        if (key.isAcceptable()) {            // 设置当前 I/O 可读            ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();            SocketChannel accept = serverSocketChannel.accept();            accept.configureBlocking(false);            accept.register(selector, SelectionKey.OP_READ);        }        // 可读就绪        else if (key.isReadable()) {            // 读取 I/O 数据            SocketChannel socketChannel = (SocketChannel) key.channel();            int len = socketChannel.read(buffer);            if (len>0) {                // 将缓冲区的偏移量归零                buffer.flip();                // 客户端请求过来的数据                String clientMsg = new String(buffer.array(), 0, len);                // 设置当前 I/O 可写                socketChannel.register(selector, SelectionKey.OP_WRITE);                key.attach("server 接收数据处理完毕，请知悉");                System.out.println("nio 服务端获得客户端请求数据："+clientMsg);            } else {                System.out.println("数据尚未读取完...");            }        }        // 可写就绪        else if (key.isWritable()) {            SocketChannel channel = (SocketChannel) key.channel();            String returnMsg = (String) key.attachment();            channel.write(ByteBuffer.wrap(returnMsg.getBytes()));            channel.close();        }    }}