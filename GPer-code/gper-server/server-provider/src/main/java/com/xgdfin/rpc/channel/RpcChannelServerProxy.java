package com.xgdfin.rpc.channel;import com.xgdfin.rpc.annotation.RpcServiceAnn;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.LengthFieldBasedFrameDecoder;import io.netty.handler.codec.LengthFieldPrepender;import io.netty.handler.codec.serialization.ClassResolvers;import io.netty.handler.codec.serialization.ObjectDecoder;import io.netty.handler.codec.serialization.ObjectEncoder;import org.springframework.beans.BeansException;import org.springframework.beans.factory.InitializingBean;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import java.util.HashMap;import java.util.Map;/* * Copyright (C) 2017  ShenZhen xinLianZhengXin Co.,Ltd All Rights Reserved. * 未经本公司正式书面同意，其他任何个人、团体不得使用、复制、修改或发布本软件. * 版权所有深圳市信联征信有限公司 http://www.credlink.com/ *//** * <p>服务端代理</p> * * @author xiehongjun * @date 11:50 2019/10/25 */@Componentpublic class RpcChannelServerProxy implements ApplicationContextAware, InitializingBean {    // 发布服务的实现类的容器    private HashMap<String, Object> serverRegistryBean = new HashMap<>();    private int port;    public RpcChannelServerProxy(int port) {        this.port = port;    }    /**     * 启动注册中心     */    private void startProxy() {        // 主线程        EventLoopGroup bossGroup = new NioEventLoopGroup();        // 工作线程        EventLoopGroup workerGroup = new NioEventLoopGroup();        try {            ServerBootstrap bootstrap = new ServerBootstrap();            bootstrap.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .childHandler(new ChannelInitializer<SocketChannel>() {                        // 初始化通道                        @Override                        protected void initChannel(SocketChannel ch) throws Exception {                            //自定义协议解码器                            /**                             * 入参有5个，分别解释如下                             * maxFrameLength：框架的最大长度。如果帧的长度大于此值，则将抛出TooLongFrameException。                             * lengthFieldOffset：长度字段的偏移量：即对应的长度字段在整个消息数据中得位置                             * lengthFieldLength：长度字段的长度。如：长度字段是int型表示，那么这个值就是4（long型就是8）                             * lengthAdjustment：要添加到长度字段值的补偿值                             * initialBytesToStrip：从解码帧中去除的第一个字节数                             */                            ChannelPipeline pipeline = ch.pipeline();                            pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));                            // 自定义协议编码器                            pipeline.addLast(new LengthFieldPrepender(4));                            // 对象参数类型编码器                            pipeline.addLast("encoder", new ObjectEncoder());                            // 对象参数类型解码器                            pipeline.addLast("decoder", new ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(null)));                            // 自定义注册处理器                            pipeline.addLast(new RpcRegistryHandler(serverRegistryBean));                        }                    })                    .option(ChannelOption.SO_BACKLOG, 128)                    .childOption(ChannelOption.SO_KEEPALIVE, true);            ChannelFuture future = bootstrap.bind(port).sync();            System.out.println("channel rpc registry start listen at " + port);            future.channel().closeFuture().sync();        } catch (Exception e) {            e.printStackTrace();        } finally {            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        }    }    /**     * bean 初始化的时候执行     */    @Override    public void afterPropertiesSet() throws Exception {        // 启动注册中心        startProxy();    }    /**     * 获取 spring 的上下文，从中找到写了 rpc 注解的实现类     */    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        // 所有写有 RpcServiceAnn 注释的类        Map<String, Object> serverImplMap = applicationContext.getBeansWithAnnotation(RpcServiceAnn.class);        // 遍历，然后放入 serverRegistryBean 这个容器        if (serverImplMap != null) {            for (Object serverImpl : serverImplMap.values()) {                // 容器 key (全类名-版本号)                String serverKey;                // 获取实现类上的注解                RpcServiceAnn rpcServiceAnn = serverImpl.getClass().getAnnotation(RpcServiceAnn.class);                /** 获取注解的值*/                // 服务接口                Class<?> serverInterface = rpcServiceAnn.value();                // 服务版本号                String version = rpcServiceAnn.version();                // 组装容器 key                serverKey = serverInterface.getCanonicalName();                if (!StringUtils.isEmpty(version)) {                    serverKey = serverKey + "-" + version;                }                // 注入容器                serverRegistryBean.put(serverKey, serverImpl);            }        }        System.out.println("本次共注入服务个数：" + serverRegistryBean.size());    }}